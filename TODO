General
    * Rename fatiando package to fat (both abreviation and acronym)
    * Write README
    * Write docs for the inverse problem theory
    * Make the examples into the cookbook
    * Make docs describing examples and link in main docs
    * Make tutorial for implementing new inversion
    * Make integration tests out of the examples
    * Include references in the modules and functions and make automatic 
      reference generation for scripts
    * Put examples in docstrings
    * Move contaminate from utils to stats
    * Allow contaminate to receive grids
    * Make a tool to remove trailing spaces from files
    * Move all the subpackage.io to a single fatiando.io module. Need to make a
      grid and profile data format
    * Make only one script for the examples and include plots in Hg

    * Speed test using json or cPickle for serialization
    
Solvers
    * Unit tests
    * Sparsity regularization
    * Use the data covariance matrix
    * Test equality constraints
    * Make virtual functions public
    
Mesh
    * Standardize data structures

Grid
    * Fix 'grid', 'nx', and 'ny' in grid.cut
    * Move utils.extract_matrices to grid.py
    * Make random grid
    * Standardize data structures and I/O format
    
Vis
    * Plot a bounding box around the a prism mesh
   
Stats
    * Unit tests
    * Implement the Chi squared test for a population
    * Implement the test for outliers in a population
    
InterG
    * Unit tests
    * Make integration test
    * Use equality constraints
    * Doesn't work with topography because it has to match the inversion mesh
      So make a function that "interpolates" the topo into the mesh

GPlant
    * Try growing only 1 seed per iteration
    * Separate the Jacobian columns per field when saving and loading
    * Migrar semente para centro de massa
    * Build sensibility in Fortran
    * Change Jacobian storage from zip to dir
    * Include option for weighted residuals
    * Implement adaptative learning
    * Unit tests
    * Make integration test
    * Test if the arms always grow in the direction the seeds are too close
    * Fix few seeds example
    * Make synthetic with boa
    
PGrav
    * Use depth weights in compact inversion
    * Build sensibility in Fortran
    * IO for initial estimate
    * Unit tests
    * Make integration test
    * Use equality constraints
    * Optimize memory usage
    * Use parameter freezing in compact inversion for speed
    * Check if using data in 2 heights is better
    
Seismo


Heat
    * Make better example script for diffusionfd1d
    * Implement VBA model
    * Implement McKenzie model
    * Implement implicit FD timestep
    * Implement diffusion with radiogenic heat
    * Implement diffusion with radiogenic heat and variable conductivity
    
Simpletom:
    * Unit tests
    * IO for initial estimate
    * Test equality constraints
    
Geometry
    * Discretize a sphere into prisms
    
Gravity
    * Program tensor invariants
    * Unit tests for existing functions
    * potential and gradients of a sphere
    * potential and derivatives of a tesseroid
    * spherical harmonics
    * reductions
    * terrain correction
    * make extention for upward continuation
    * equivalent layer
    * Put all constants used into a constants.py module and pass them to the C
      functions
    * Implement derivatives in equivalent layer
    * Normalize Jacobian so that reg params are in range 0-1
    * Optimize equivalent layer
    * Implement equivalent data in equivalent layer (Mendonca)
    * Implement polynomial equivalent layer
    * Make all synthetic functions receive a grid object
    
WaveFD:
    * Port to Fortran
    * Get rid of Python interface (put it in seismo.synthetic)
    
