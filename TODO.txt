General
    * Write better (or any at all) docs for the inverse problem theory
    * Make example wikis
    * Make tutorial for implementing new inversion
    * Make integration tests out of the examples
    * Include references in the modules and functions and make automatic 
      reference generation for scripts
    * Move fill_mesh to to mesh.py 
    Done:
    * Change C code that uses arrays to Fortran
    
Inversion
    * Unit tests
    * Sparsity regularization
    * Use the data covariance matrix
    * Test equality constraints
    Done
    * Implement equality constraints
    * Linear solver
    * Implement log barrier
   
Stats
    * Unit tests
    * Implement the Chi squared test for a population
    * Implement the test for outliers in a population
    
InterG
    * Unit tests
    * Make integration test
    * Use equality constraints
    * Doesn't work with topography because it has to match the inversion mesh
      So make a function that "interpolates" the topo into the mesh
    Done:
    * Function descriptions in the docstring
    * Make visualizations
    * Port to the new solvers.py
    * Make synthetic data generation
    * IO for inversion results and initial estimate
    * Use log barrier
    * Finish example scripts
    * Test the port to new solvers.py (the problem was in exaggerate)
    
PGrav
    * Testar remover celula quando redistribui
    * Migrar semente para centro de massa
    * Aumentar regularizador quando redistribui
    * Redistribute only the farthest
    * Put redistribution in a separate function so that I can call it whenever
      I want later
    * Build sensibility in Fortran
    * Allow initial estimate in grow
    * Unit tests
    * IO for initial estimate
    * Make integration test
    * Use equality constraints
    Done:
    * Aglutinar uma celula por semente (no minimo)
    * Redistribuir somente na borda
    * Restrict common neighbors for seeds 
    * Port to the new solvers.py
    * Make visualizations
    * Implement depth weights
    * IO for inversion results (pickle the mesh)
    * Calcular distancia usando casca e nao centro dos prismas
    * Quando nao adiciona, redistribui massa. Para quando nao redistribiu e nao 
      adiciona
    * Colocar potencia da distancia como prarametro
    
Seismo

    Done:
    * Module descriptions in the docstring
    
Simpletom:
    * Unit tests
    * IO for initial estimate
    * Use equality constraints

    Done:
    * Use log barrier
    * Put versbose in solve and make_mesh
    * Port to the new solvers.py
    * Make visualizations
    * Make synthetic data generatio
    * IO for inversion results (pickle the mesh)
    
Geometry
    * Discretize a sphere into prisms
    
        
Gravity
    * Unit tests for existing functions
    * potential and derivatives of a sphere
    * potential and derivatives of a tesseroid
    * spherical harmonics
    * reductions
    * terrain correction
    * continuation
    * equivalent layer
    
    Done:    
    * Make synthetic data generation
    * Make io module with load and dump functions
    
WaveFD:
    * Port to Fortran
    * Get rid of Python interface (put it in seismo.synthetic)
    